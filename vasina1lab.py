import numpy as np
import pandas as pd
from scipy import linalg

# ============== 1. ЗАГРУЗКА ДАННЫХ ВАРИАНТА 3 ==============
data = np.array([
    [3, 130, 2.530, 12.123, 107, 103],
    [3, 113, 7.960, 8.247, 294, 262],
    [3, 139, 1.750, 10.351, 146, 136],
    [4, 109, 5.233, 13.635, 155, 144],
    [3, 106, 10.537, 4.555, 298, 266],
    [3, 98, 10.966, 10.807, 241, 217],
    [2, 82, 7.611, 9.859, 181, 166],
    [2, 149, 5.592, 13.097, 232, 209],
    [4, 84, 8.218, 5.202, 108, 104],
    [3, 95, 8.391, 4.156, 111, 107],
    [3, 121, 1.987, 7.625, 305, 272],
    [3, 137, 9.128, 9.880, 144, 135],
    [3, 128, 3.436, 5.099, 259, 233],
    [3, 81, 5.929, 6.372, 297, 265],
    [4, 71, 9.393, 12.291, 82, 82],
    [2, 138, 9.314, 8.072, 246, 222],
    [3, 123, 9.352, 13.062, 261, 234],
    [3, 73, 3.504, 14.610, 186, 170],
    [4, 139, 0.517, 10.083, 340, 302],
    [3, 127, 8.398, 6.499, 87, 86],
    [3, 84, 6.568, 11.383, 193, 176],
    [3, 92, 2.373, 9.264, 318, 282],
    [3, 85, 9.894, 9.193, 105, 101],
    [4, 119, 6.777, 9.077, 180, 165],
    [2, 82, 6.329, 11.911, 89, 87],
    [3, 135, 8.278, 14.520, 264, 237],
    [4, 145, 8.141, 8.548, 323, 287],
    [2, 146, 9.438, 14.548, 301, 269],
    [4, 86, 4.794, 14.494, 165, 152],
    [2, 79, 9.670, 6.264, 314, 279]
])

# Названия переменных
variables = ['X1', 'X2', 'X3', 'X4', 'X5', 'X6']
n_obs, n_vars = data.shape

# ============== 2. НОРМИРОВАНИЕ ДАННЫХ ==============
means = np.mean(data, axis=0)
stds = np.std(data, axis=0, ddof=1)
Z = (data - means) / stds  # Нормированная матрица T

# ============== 3. МАТРИЦА КОРРЕЛЯЦИЙ R ==============
R = np.corrcoef(data.T)  # Матрица парных коэффициентов корреляции

print("Матрица корреляций R:")
print(np.round(R, 3))

# ============== 4. СОБСТВЕННЫЕ ЗНАЧЕНИЯ И ВЕКТОРЫ ==============
eigvals, eigvecs = linalg.eig(R)
eigvals = eigvals.real
eigvecs = eigvecs.real

# Сортируем по убыванию собственных значений
idx = eigvals.argsort()[::-1]
eigvals = eigvals[idx]
eigvecs = eigvecs[:, idx]

print("\nСобственные значения:")
for i, val in enumerate(eigvals, 1):
    print(f"λ{i} = {val:.4f}")

# ============== 5. ОГРАНИЧЕНИЕ ЧИСЛА ФАКТОРОВ (ценз = 1) ==============
# Выбираем только собственные значения > 1 (по условию только одно)
selected = eigvals > 1
k = sum(selected)  # число отобранных факторов
print(f"\nОтобрано факторов: {k} (с λ > 1)")

# ============== 6. ФАКТОРНЫЕ НАГРУЗКИ (для одного фактора) ==============
A = eigvecs[:, :k] * np.sqrt(eigvals[:k])  # матрица нагрузок A

print("\nФакторные нагрузки (матрица A):")
for var, load in zip(variables, A[:, 0]):
    print(f"{var}: {load:.4f}")

# ============== 7. ПРОВЕРКА ПРОСТОЙ СТРУКТУРЫ ==============
# Для одного фактора вращение не проводится (оно нужно для 2+ факторов)
print("\nВращение не требуется (один фактор).")

# ============== 8. ЗНАЧЕНИЯ ФАКТОРА ДЛЯ КАЖДОГО НАБЛЮДЕНИЯ ==============
# Используем формулу P = Z * A (нормированные данные * нагрузки)
F = Z @ A  # матрица значений фактора (30x1)

print("\nЗначения фактора для каждого наблюдения:")
for i, val in enumerate(F[:, 0], 1):
    print(f"Наблюдение {i:2d}: {val:.4f}")

# ============== 9. ВЫВОДЫ ==============
print("\n" + "="*50)
print("ВЫВОДЫ:")
print("="*50)
print("1. Собственные значения матрицы R:")
for i, val in enumerate(eigvals, 1):
    print(f"   λ{i} = {val:.3f}")
print(f"   Только λ1 = {eigvals[0]:.3f} > 1, поэтому выбран один фактор.")

print("\n2. Факторные нагрузки показывают вклад каждой переменной в фактор:")
loads = A[:, 0]
for var, load in zip(variables, loads):
    print(f"   {var}: {load:.3f}")

print("\n3. Наибольший вклад в фактор вносят:")
abs_loads = np.abs(loads)
top_idx = np.argsort(abs_loads)[::-1]
for i in range(3):
    idx = top_idx[i]
    print(f"   {i+1}. {variables[idx]} ({loads[idx]:.3f})")

print("\n4. Фактор можно интерпретировать как:")
print("   Общий показатель производственной эффективности, объединяющий")
print("   оборотные/основные фонды, производительность и выпуск продукции.")

print("\n5. Значения фактора варьируются от {:.3f} до {:.3f}".format(F.min(), F.max()))
print("   Это позволяет ранжировать фирмы по уровню эффективности.")